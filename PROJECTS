Open jobs for finishing GNU libc:
---------------------------------
Status: March 1997

If you have time and talent to take over any of the jobs below please
contact <bug-glibc@prep.ai.mit.edu>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[ 1] Port to new platforms or test current version on formerly supported
     platforms.

**** See http://www.gnu.org/software/libc/porting.html for more details.


[ 2] Test compliance with standards.  If you have access to recent
     standards (IEEE, ISO, ANSI, X/Open, ...) and/or test suites you
     could do some checks as the goal is to be compliant with all
     standards if they do not contradict each other.


[ 3] The IMHO opinion most important task is to write a more complete
     test suite.  We cannot get too many people working on this.  It is
     not difficult to write a test, find a definition of the function
     which I normally can provide, if necessary, and start writing tests
     to test for compliance.  Beside this, take a look at the sources
     and write tests which in total test as many paths of execution as
     possible.


[ 4] Write translations for the GNU libc message for the so far
     unsupported languages.  GNU libc is fully internationalized and
     users can immediately benefit from this.

     Take a look at the matrix in
	ftp://prep.ai.mit.edu/pub/gnu/ABOUT-NLS
     for the current status (of course better use a mirror of prep).


[ 5] Write wordexp() function; this is described in POSIX.2, the
     header <wordexp.h> already exists.

     Implementation idea: use some functions from bash.

**** Somebody is working on this.  Help may or may not be appreciated.


[ 6] Write `long double' versions of the math functions.  This should be
     done in collaboration with the NetBSD and FreeBSD people.

     The libm is in fact fdlibm (not the same as in Linux libc).

**** Partly done.  But we need someone with numerical experiences for
     the rest.


[ 7] Several math functions have to be written:

     - exp2
     - log2

     each with float, double, and long double arguments.  Writing these
     functions should be possible when following the implementation of
     the existing exp/log functions for other bases.

     Beside this most of the complex math functions which are new in
     ISO C 9X.  gcc already has support for numbers of complex type so the
     implementation should be possible today.  I mention here the names
     and the way to write them (argument is z = x + iy):

     - cexp(z)	= e^x (cos y + i sin y)
     - sin(z)	= 1/(2i) (e^(iz) - e^-(iz)) = sin(x) cosh(y) + i cos(x) sinh(y)
     - cos(z)	= 1/2 (e^(iz) + e^-(iz)) = cos(x) cosh(y) - i sin(x) sinh(y)
     - tan(z)	= 1/i (e^(iz) - e^-(iz))/(e^(iz) + e^-(iz))
     - cot(z)	= i (e^(iz) + e^-(iz))/(e^(iz) - e^-(iz))
     - asin(z)	= -i ln(iz + sqrt(1-z^2))
     - acos(z)	= -i ln(z + sqrt(z^2-1))
     - atan(z)	= 1/(2i) ln((1+iz)/(1-iz))
     - acot(z)	= -1/(2i) ln((iz+1)/(iz-1))
     - sinh(z)	= 1/2 (e^z - e^-z)
     - cosh(z)	= 1/2 (e^z + e^-z)
     - tanh(z)	= (e^z - e^-z)/(e^z + e^-z)
     - coth(z)	= (e^z + e^-z)/(e^z - e^-z)

     All functions should we written with all the parallelism in mind.
     And assembler versions are highly expreciated since, e.g., the ix87
     FPU provides an `fsincos' instructions which is certainly useful for
     the `sin' function.  The implementations for the normal math functions
     shows other optimization techniques.


[ 8] If you enjoy assembler programming (as I do --drepper :-) you might
     be interested in writing optimized versions for some functions.
     Especially the string handling functions can be optimized a lot.

     Take a look at

	Faster String Functions
	Henry Spencer, University of Toronto
	Usenix Winter '92, pp. 419--428

     or just ask.  Currently mostly i?86 and Alpha optimized versions
     exist.  Please ask before working on this to avoid duplicate
     work.


[ 9] Write nftw() function.  Perhaps it might be good to reimplement the
     ftw() function as well to share most of the code.

**** Almost done!


[10] Write AVL-tree based tsearch() et.al. functions.  Currently only
     a very simple algorithm is used.
     There is a public domain version but using this would cause problems
     with the assignment.


[11] Extend regex and/or rx to work with wide characters and complete
     implementation of character class and collation class handling.

     It is planed to do a complete rewrite.


[12] Write access function for netmasks, bootparams, and automount
     databases for nss_files and nss_db module.
     The functions should be embedded in the nss scheme.  This is not
     hard and not all services must be supported at once.


[13] Rewrite utmp/wtmp functions to use database functions.  This is much
     better than the normal flat file format.

**** There are plans for a new approach to this problem.  Please contact
     bug-glibc@prep.ai.mit.edu before starting to work.)


[14] Several more or less small functions have to be written:

     + tcgetid() and waitid()			from XPG4.2
     + grantpt(), ptsname(), unlockpt()		from XPG4.2
     + getdate()				from XPG4.2
     + fmtmsg()					from SVID

     More information are available on request.


[15] We need to write a library for on-the-fly transformation of streams
     of text.  In fact, this would be a recode-library (you know, GNU recode).
     This is needed in several places in the GNU libc and I already have
     rather concrete plans but so far no possibility to start this.
